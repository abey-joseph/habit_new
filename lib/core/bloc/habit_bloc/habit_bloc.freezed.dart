// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'habit_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HabitEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HabitEventCopyWith<$Res> {
  factory $HabitEventCopyWith(
          HabitEvent value, $Res Function(HabitEvent) then) =
      _$HabitEventCopyWithImpl<$Res, HabitEvent>;
}

/// @nodoc
class _$HabitEventCopyWithImpl<$Res, $Val extends HabitEvent>
    implements $HabitEventCopyWith<$Res> {
  _$HabitEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$fetchHabitImplCopyWith<$Res> {
  factory _$$fetchHabitImplCopyWith(
          _$fetchHabitImpl value, $Res Function(_$fetchHabitImpl) then) =
      __$$fetchHabitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$fetchHabitImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$fetchHabitImpl>
    implements _$$fetchHabitImplCopyWith<$Res> {
  __$$fetchHabitImplCopyWithImpl(
      _$fetchHabitImpl _value, $Res Function(_$fetchHabitImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$fetchHabitImpl implements fetchHabit {
  const _$fetchHabitImpl();

  @override
  String toString() {
    return 'HabitEvent.fetchHabit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$fetchHabitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return fetchHabit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return fetchHabit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (fetchHabit != null) {
      return fetchHabit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return fetchHabit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return fetchHabit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (fetchHabit != null) {
      return fetchHabit(this);
    }
    return orElse();
  }
}

abstract class fetchHabit implements HabitEvent {
  const factory fetchHabit() = _$fetchHabitImpl;
}

/// @nodoc
abstract class _$$addHabitsImplCopyWith<$Res> {
  factory _$$addHabitsImplCopyWith(
          _$addHabitsImpl value, $Res Function(_$addHabitsImpl) then) =
      __$$addHabitsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String habitName});
}

/// @nodoc
class __$$addHabitsImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$addHabitsImpl>
    implements _$$addHabitsImplCopyWith<$Res> {
  __$$addHabitsImplCopyWithImpl(
      _$addHabitsImpl _value, $Res Function(_$addHabitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? habitName = null,
  }) {
    return _then(_$addHabitsImpl(
      habitName: null == habitName
          ? _value.habitName
          : habitName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$addHabitsImpl implements addHabits {
  const _$addHabitsImpl({required this.habitName});

  @override
  final String habitName;

  @override
  String toString() {
    return 'HabitEvent.addHabits(habitName: $habitName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$addHabitsImpl &&
            (identical(other.habitName, habitName) ||
                other.habitName == habitName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, habitName);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$addHabitsImplCopyWith<_$addHabitsImpl> get copyWith =>
      __$$addHabitsImplCopyWithImpl<_$addHabitsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return addHabits(habitName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return addHabits?.call(habitName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (addHabits != null) {
      return addHabits(habitName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return addHabits(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return addHabits?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (addHabits != null) {
      return addHabits(this);
    }
    return orElse();
  }
}

abstract class addHabits implements HabitEvent {
  const factory addHabits({required final String habitName}) = _$addHabitsImpl;

  String get habitName;

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$addHabitsImplCopyWith<_$addHabitsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$deleteHabitsImplCopyWith<$Res> {
  factory _$$deleteHabitsImplCopyWith(
          _$deleteHabitsImpl value, $Res Function(_$deleteHabitsImpl) then) =
      __$$deleteHabitsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$deleteHabitsImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$deleteHabitsImpl>
    implements _$$deleteHabitsImplCopyWith<$Res> {
  __$$deleteHabitsImplCopyWithImpl(
      _$deleteHabitsImpl _value, $Res Function(_$deleteHabitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$deleteHabitsImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$deleteHabitsImpl implements deleteHabits {
  const _$deleteHabitsImpl({required this.index});

  @override
  final int index;

  @override
  String toString() {
    return 'HabitEvent.deleteHabits(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$deleteHabitsImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$deleteHabitsImplCopyWith<_$deleteHabitsImpl> get copyWith =>
      __$$deleteHabitsImplCopyWithImpl<_$deleteHabitsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return deleteHabits(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return deleteHabits?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (deleteHabits != null) {
      return deleteHabits(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return deleteHabits(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return deleteHabits?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (deleteHabits != null) {
      return deleteHabits(this);
    }
    return orElse();
  }
}

abstract class deleteHabits implements HabitEvent {
  const factory deleteHabits({required final int index}) = _$deleteHabitsImpl;

  int get index;

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$deleteHabitsImplCopyWith<_$deleteHabitsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$editHabitImplCopyWith<$Res> {
  factory _$$editHabitImplCopyWith(
          _$editHabitImpl value, $Res Function(_$editHabitImpl) then) =
      __$$editHabitImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index, String habitName});
}

/// @nodoc
class __$$editHabitImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$editHabitImpl>
    implements _$$editHabitImplCopyWith<$Res> {
  __$$editHabitImplCopyWithImpl(
      _$editHabitImpl _value, $Res Function(_$editHabitImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? habitName = null,
  }) {
    return _then(_$editHabitImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      habitName: null == habitName
          ? _value.habitName
          : habitName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$editHabitImpl implements editHabit {
  const _$editHabitImpl({required this.index, required this.habitName});

  @override
  final int index;
  @override
  final String habitName;

  @override
  String toString() {
    return 'HabitEvent.editHabit(index: $index, habitName: $habitName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$editHabitImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.habitName, habitName) ||
                other.habitName == habitName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index, habitName);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$editHabitImplCopyWith<_$editHabitImpl> get copyWith =>
      __$$editHabitImplCopyWithImpl<_$editHabitImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return editHabit(index, habitName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return editHabit?.call(index, habitName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (editHabit != null) {
      return editHabit(index, habitName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return editHabit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return editHabit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (editHabit != null) {
      return editHabit(this);
    }
    return orElse();
  }
}

abstract class editHabit implements HabitEvent {
  const factory editHabit(
      {required final int index,
      required final String habitName}) = _$editHabitImpl;

  int get index;
  String get habitName;

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$editHabitImplCopyWith<_$editHabitImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$refreshHabitImplCopyWith<$Res> {
  factory _$$refreshHabitImplCopyWith(
          _$refreshHabitImpl value, $Res Function(_$refreshHabitImpl) then) =
      __$$refreshHabitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$refreshHabitImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$refreshHabitImpl>
    implements _$$refreshHabitImplCopyWith<$Res> {
  __$$refreshHabitImplCopyWithImpl(
      _$refreshHabitImpl _value, $Res Function(_$refreshHabitImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$refreshHabitImpl implements refreshHabit {
  const _$refreshHabitImpl();

  @override
  String toString() {
    return 'HabitEvent.refreshHabit()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$refreshHabitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return refreshHabit();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return refreshHabit?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (refreshHabit != null) {
      return refreshHabit();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return refreshHabit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return refreshHabit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (refreshHabit != null) {
      return refreshHabit(this);
    }
    return orElse();
  }
}

abstract class refreshHabit implements HabitEvent {
  const factory refreshHabit() = _$refreshHabitImpl;
}

/// @nodoc
abstract class _$$dateChangedImplCopyWith<$Res> {
  factory _$$dateChangedImplCopyWith(
          _$dateChangedImpl value, $Res Function(_$dateChangedImpl) then) =
      __$$dateChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime currentDate, DateTime lastEntryDate});
}

/// @nodoc
class __$$dateChangedImplCopyWithImpl<$Res>
    extends _$HabitEventCopyWithImpl<$Res, _$dateChangedImpl>
    implements _$$dateChangedImplCopyWith<$Res> {
  __$$dateChangedImplCopyWithImpl(
      _$dateChangedImpl _value, $Res Function(_$dateChangedImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentDate = null,
    Object? lastEntryDate = null,
  }) {
    return _then(_$dateChangedImpl(
      currentDate: null == currentDate
          ? _value.currentDate
          : currentDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastEntryDate: null == lastEntryDate
          ? _value.lastEntryDate
          : lastEntryDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$dateChangedImpl implements dateChanged {
  const _$dateChangedImpl(
      {required this.currentDate, required this.lastEntryDate});

  @override
  final DateTime currentDate;
  @override
  final DateTime lastEntryDate;

  @override
  String toString() {
    return 'HabitEvent.dateChanged(currentDate: $currentDate, lastEntryDate: $lastEntryDate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$dateChangedImpl &&
            (identical(other.currentDate, currentDate) ||
                other.currentDate == currentDate) &&
            (identical(other.lastEntryDate, lastEntryDate) ||
                other.lastEntryDate == lastEntryDate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, currentDate, lastEntryDate);

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$dateChangedImplCopyWith<_$dateChangedImpl> get copyWith =>
      __$$dateChangedImplCopyWithImpl<_$dateChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchHabit,
    required TResult Function(String habitName) addHabits,
    required TResult Function(int index) deleteHabits,
    required TResult Function(int index, String habitName) editHabit,
    required TResult Function() refreshHabit,
    required TResult Function(DateTime currentDate, DateTime lastEntryDate)
        dateChanged,
  }) {
    return dateChanged(currentDate, lastEntryDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fetchHabit,
    TResult? Function(String habitName)? addHabits,
    TResult? Function(int index)? deleteHabits,
    TResult? Function(int index, String habitName)? editHabit,
    TResult? Function()? refreshHabit,
    TResult? Function(DateTime currentDate, DateTime lastEntryDate)?
        dateChanged,
  }) {
    return dateChanged?.call(currentDate, lastEntryDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchHabit,
    TResult Function(String habitName)? addHabits,
    TResult Function(int index)? deleteHabits,
    TResult Function(int index, String habitName)? editHabit,
    TResult Function()? refreshHabit,
    TResult Function(DateTime currentDate, DateTime lastEntryDate)? dateChanged,
    required TResult orElse(),
  }) {
    if (dateChanged != null) {
      return dateChanged(currentDate, lastEntryDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(fetchHabit value) fetchHabit,
    required TResult Function(addHabits value) addHabits,
    required TResult Function(deleteHabits value) deleteHabits,
    required TResult Function(editHabit value) editHabit,
    required TResult Function(refreshHabit value) refreshHabit,
    required TResult Function(dateChanged value) dateChanged,
  }) {
    return dateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(fetchHabit value)? fetchHabit,
    TResult? Function(addHabits value)? addHabits,
    TResult? Function(deleteHabits value)? deleteHabits,
    TResult? Function(editHabit value)? editHabit,
    TResult? Function(refreshHabit value)? refreshHabit,
    TResult? Function(dateChanged value)? dateChanged,
  }) {
    return dateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(fetchHabit value)? fetchHabit,
    TResult Function(addHabits value)? addHabits,
    TResult Function(deleteHabits value)? deleteHabits,
    TResult Function(editHabit value)? editHabit,
    TResult Function(refreshHabit value)? refreshHabit,
    TResult Function(dateChanged value)? dateChanged,
    required TResult orElse(),
  }) {
    if (dateChanged != null) {
      return dateChanged(this);
    }
    return orElse();
  }
}

abstract class dateChanged implements HabitEvent {
  const factory dateChanged(
      {required final DateTime currentDate,
      required final DateTime lastEntryDate}) = _$dateChangedImpl;

  DateTime get currentDate;
  DateTime get lastEntryDate;

  /// Create a copy of HabitEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$dateChangedImplCopyWith<_$dateChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HabitState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> habits) loaded,
    required TResult Function(String e) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> habits)? loaded,
    TResult? Function(String e)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> habits)? loaded,
    TResult Function(String e)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(initial value) initial,
    required TResult Function(loading value) loading,
    required TResult Function(loaded value) loaded,
    required TResult Function(error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(initial value)? initial,
    TResult? Function(loading value)? loading,
    TResult? Function(loaded value)? loaded,
    TResult? Function(error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(initial value)? initial,
    TResult Function(loading value)? loading,
    TResult Function(loaded value)? loaded,
    TResult Function(error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HabitStateCopyWith<$Res> {
  factory $HabitStateCopyWith(
          HabitState value, $Res Function(HabitState) then) =
      _$HabitStateCopyWithImpl<$Res, HabitState>;
}

/// @nodoc
class _$HabitStateCopyWithImpl<$Res, $Val extends HabitState>
    implements $HabitStateCopyWith<$Res> {
  _$HabitStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$initialImplCopyWith<$Res> {
  factory _$$initialImplCopyWith(
          _$initialImpl value, $Res Function(_$initialImpl) then) =
      __$$initialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$initialImplCopyWithImpl<$Res>
    extends _$HabitStateCopyWithImpl<$Res, _$initialImpl>
    implements _$$initialImplCopyWith<$Res> {
  __$$initialImplCopyWithImpl(
      _$initialImpl _value, $Res Function(_$initialImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$initialImpl implements initial {
  const _$initialImpl();

  @override
  String toString() {
    return 'HabitState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$initialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> habits) loaded,
    required TResult Function(String e) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> habits)? loaded,
    TResult? Function(String e)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> habits)? loaded,
    TResult Function(String e)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(initial value) initial,
    required TResult Function(loading value) loading,
    required TResult Function(loaded value) loaded,
    required TResult Function(error value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(initial value)? initial,
    TResult? Function(loading value)? loading,
    TResult? Function(loaded value)? loaded,
    TResult? Function(error value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(initial value)? initial,
    TResult Function(loading value)? loading,
    TResult Function(loaded value)? loaded,
    TResult Function(error value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class initial implements HabitState {
  const factory initial() = _$initialImpl;
}

/// @nodoc
abstract class _$$loadingImplCopyWith<$Res> {
  factory _$$loadingImplCopyWith(
          _$loadingImpl value, $Res Function(_$loadingImpl) then) =
      __$$loadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$loadingImplCopyWithImpl<$Res>
    extends _$HabitStateCopyWithImpl<$Res, _$loadingImpl>
    implements _$$loadingImplCopyWith<$Res> {
  __$$loadingImplCopyWithImpl(
      _$loadingImpl _value, $Res Function(_$loadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$loadingImpl implements loading {
  const _$loadingImpl();

  @override
  String toString() {
    return 'HabitState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$loadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> habits) loaded,
    required TResult Function(String e) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> habits)? loaded,
    TResult? Function(String e)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> habits)? loaded,
    TResult Function(String e)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(initial value) initial,
    required TResult Function(loading value) loading,
    required TResult Function(loaded value) loaded,
    required TResult Function(error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(initial value)? initial,
    TResult? Function(loading value)? loading,
    TResult? Function(loaded value)? loaded,
    TResult? Function(error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(initial value)? initial,
    TResult Function(loading value)? loading,
    TResult Function(loaded value)? loaded,
    TResult Function(error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class loading implements HabitState {
  const factory loading() = _$loadingImpl;
}

/// @nodoc
abstract class _$$loadedImplCopyWith<$Res> {
  factory _$$loadedImplCopyWith(
          _$loadedImpl value, $Res Function(_$loadedImpl) then) =
      __$$loadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> habits});
}

/// @nodoc
class __$$loadedImplCopyWithImpl<$Res>
    extends _$HabitStateCopyWithImpl<$Res, _$loadedImpl>
    implements _$$loadedImplCopyWith<$Res> {
  __$$loadedImplCopyWithImpl(
      _$loadedImpl _value, $Res Function(_$loadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? habits = null,
  }) {
    return _then(_$loadedImpl(
      habits: null == habits
          ? _value._habits
          : habits // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$loadedImpl implements loaded {
  const _$loadedImpl({required final List<String> habits}) : _habits = habits;

  final List<String> _habits;
  @override
  List<String> get habits {
    if (_habits is EqualUnmodifiableListView) return _habits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_habits);
  }

  @override
  String toString() {
    return 'HabitState.loaded(habits: $habits)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$loadedImpl &&
            const DeepCollectionEquality().equals(other._habits, _habits));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_habits));

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$loadedImplCopyWith<_$loadedImpl> get copyWith =>
      __$$loadedImplCopyWithImpl<_$loadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> habits) loaded,
    required TResult Function(String e) error,
  }) {
    return loaded(habits);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> habits)? loaded,
    TResult? Function(String e)? error,
  }) {
    return loaded?.call(habits);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> habits)? loaded,
    TResult Function(String e)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(habits);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(initial value) initial,
    required TResult Function(loading value) loading,
    required TResult Function(loaded value) loaded,
    required TResult Function(error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(initial value)? initial,
    TResult? Function(loading value)? loading,
    TResult? Function(loaded value)? loaded,
    TResult? Function(error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(initial value)? initial,
    TResult Function(loading value)? loading,
    TResult Function(loaded value)? loaded,
    TResult Function(error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class loaded implements HabitState {
  const factory loaded({required final List<String> habits}) = _$loadedImpl;

  List<String> get habits;

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$loadedImplCopyWith<_$loadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$errorImplCopyWith<$Res> {
  factory _$$errorImplCopyWith(
          _$errorImpl value, $Res Function(_$errorImpl) then) =
      __$$errorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String e});
}

/// @nodoc
class __$$errorImplCopyWithImpl<$Res>
    extends _$HabitStateCopyWithImpl<$Res, _$errorImpl>
    implements _$$errorImplCopyWith<$Res> {
  __$$errorImplCopyWithImpl(
      _$errorImpl _value, $Res Function(_$errorImpl) _then)
      : super(_value, _then);

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? e = null,
  }) {
    return _then(_$errorImpl(
      e: null == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$errorImpl implements error {
  const _$errorImpl({required this.e});

  @override
  final String e;

  @override
  String toString() {
    return 'HabitState.error(e: $e)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$errorImpl &&
            (identical(other.e, e) || other.e == e));
  }

  @override
  int get hashCode => Object.hash(runtimeType, e);

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$errorImplCopyWith<_$errorImpl> get copyWith =>
      __$$errorImplCopyWithImpl<_$errorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> habits) loaded,
    required TResult Function(String e) error,
  }) {
    return error(e);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> habits)? loaded,
    TResult? Function(String e)? error,
  }) {
    return error?.call(e);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> habits)? loaded,
    TResult Function(String e)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(e);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(initial value) initial,
    required TResult Function(loading value) loading,
    required TResult Function(loaded value) loaded,
    required TResult Function(error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(initial value)? initial,
    TResult? Function(loading value)? loading,
    TResult? Function(loaded value)? loaded,
    TResult? Function(error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(initial value)? initial,
    TResult Function(loading value)? loading,
    TResult Function(loaded value)? loaded,
    TResult Function(error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class error implements HabitState {
  const factory error({required final String e}) = _$errorImpl;

  String get e;

  /// Create a copy of HabitState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$errorImplCopyWith<_$errorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
